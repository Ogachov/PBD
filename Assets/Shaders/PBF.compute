// PBF.compute - with recycle pass (no add/remove on GPU; CPU emits; GPU recycles fallen particles)
#pragma kernel ClearGrid
#pragma kernel BuildGrid
#pragma kernel Predict
#pragma kernel ComputeLambda
#pragma kernel ComputeDelta
#pragma kernel ApplyBoundary
#pragma kernel RecycleBelow
#pragma kernel UpdateVelocity

struct Particle {
    float3 x;
    float3 v;
    float  rho;
    float  lambda;
};

RWStructuredBuffer<Particle> _Particles;
RWStructuredBuffer<float3>   _OldPos;
RWStructuredBuffer<int>      _CellHead;
RWStructuredBuffer<int>      _Next;

int    _NumParticles;
float3 _GridMin;
int3   _GridRes;
float  _CellSize;
float  _H;
float  _RestDensity;
float  _Epsilon;
float  _DeltaTime;
float3 _Gravity;
float  _XSPH;
float  _BoundaryDamp;

// Emitter / recycle params
int    _Frame;
float3 _EmitterCenter;
float3 _EmitterSize;
float3 _EmitVel;
float  _RecycleY;

#define MAX_NEIGHBORS 96
#define PI 3.14159265359

float W_poly6(float r){
    if (r>=_H) return 0;
    float x = (_H*_H - r*r);
    float k = 315.0/(64.0*PI*pow(_H,9));
    return k*x*x*x;
}
float3 gradW_spiky(float3 rvec){
    float r = length(rvec);
    if (r<=1e-8 || r>=_H) return 0;
    float k = -45.0/(PI*pow(_H,6));
    return k * pow(_H - r, 2) * (rvec/r);
}

int3 PosToCoord(float3 p){
    float3 q = (p - _GridMin) / _CellSize;
    return clamp((int3)floor(q), int3(0,0,0), _GridRes-1);
}
int CoordToId(int3 c){ return (c.z*_GridRes.y + c.y)*_GridRes.x + c.x; }

// tiny hash -> [0,1)
float hash11(uint n){
    n = (n<<13) ^ n;
    uint nn = n*(n*n*15731u + 789221u) + 1376312589u;
    return frac(nn / 4294967296.0);
}
float3 rand31(uint baseSeed){
    return float3(hash11(baseSeed*1663u+1u)*2-1,
                  hash11(baseSeed*3259u+7u)*2-1,
                  hash11(baseSeed*811u +13u)*2-1);
}

[numthreads(128,1,1)]
void ClearGrid(uint id:SV_DispatchThreadID){
    uint total = (uint)(_GridRes.x*_GridRes.y*_GridRes.z);
    if (id < total) _CellHead[id] = -1;
}

[numthreads(128,1,1)]
void BuildGrid(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle p = _Particles[i];
    int3 c = PosToCoord(p.x);
    int  cid = CoordToId(c);

    int oldHead;
    InterlockedExchange(_CellHead[cid], (int)i, oldHead);
    _Next[i] = oldHead;
}

void ForEachNeighbor(uint i, float3 xi, inout int count, inout uint neighbors[MAX_NEIGHBORS]){
    int3 c = PosToCoord(xi);
    [unroll] for(int dz=-1; dz<=1; ++dz)
    [unroll] for(int dy=-1; dy<=1; ++dy)
    [unroll] for(int dx=-1; dx<=1; ++dx){
        int3 nc = c + int3(dx,dy,dz);
        if(any(nc<0) || any(nc>=_GridRes)) continue;
        int head = _CellHead[CoordToId(nc)];
        while(head!=-1){
            if (head!=i){
                neighbors[count++] = head;
                if (count>=MAX_NEIGHBORS) return;
            }
            head = _Next[head];
        }
    }
}

[numthreads(128,1,1)]
void Predict(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle p = _Particles[i];
    _OldPos[i] = p.x;
    p.v += _Gravity * _DeltaTime;
    p.x += p.v * _DeltaTime;
    _Particles[i] = p;
}

[numthreads(128,1,1)]
void ComputeLambda(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle pi = _Particles[i];
    float3 xi = pi.x;

    uint neigh[MAX_NEIGHBORS]; int ncount=0;
    ForEachNeighbor(i, xi, ncount, neigh);

    float rho = W_poly6(0);
    for(int k=0;k<ncount;k++){
        Particle pj = _Particles[neigh[k]];
        rho += W_poly6(distance(xi, pj.x));
    }
    rho *= _RestDensity;
    pi.rho = rho;

    float3 sumGrad = 0;
    float grad2 = 0;
    for(int k=0;k<ncount;k++){
        Particle pj = _Particles[neigh[k]];
        float3 gij = gradW_spiky(xi - pj.x) / _RestDensity;
        sumGrad += gij;
        grad2 += dot(gij,gij);
    }
    float3 gii = -sumGrad;
    grad2 += dot(gii,gii);

    float C = rho/_RestDensity - 1.0;
    pi.lambda = -C / (grad2 + _Epsilon);
    _Particles[i] = pi;
}

[numthreads(128,1,1)]
void ComputeDelta(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle pi = _Particles[i];
    float3 xi = pi.x;

    uint neigh[MAX_NEIGHBORS]; int ncount=0;
    ForEachNeighbor(i, xi, ncount, neigh);

    float3 delta = 0;
    float3 xsph  = 0;

    const float k = 0.001;
    const float n = 4.0;
    const float q = 0.3;
    float wq = W_poly6(q*_H);

    for(int k2=0;k2<ncount;k2++){
        uint j = neigh[k2];
        Particle pj = _Particles[j];
        float3 rij = xi - pj.x;
        float  r   = length(rij);
        float3 grad = gradW_spiky(rij) / _RestDensity;

        float w = W_poly6(r);
        float scorr = -k * pow(w/(wq+1e-8), n);
        float lambdaSum = pi.lambda + pj.lambda + scorr;
        delta += lambdaSum * grad;

        xsph += (pj.v - pi.v) * w;
    }
    pi.x += delta;
    if (_XSPH>0) pi.v += _XSPH * xsph;
    _Particles[i] = pi;
}

float3 ClampAABB(float3 x){
    float3 minB = _GridMin + _CellSize;
    float3 maxB = _GridMin + (float3)_GridRes * _CellSize - _CellSize;
    return clamp(x, minB, maxB);
}

[numthreads(128,1,1)]
void ApplyBoundary(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle p = _Particles[i];
    float3 before = p.x;
    p.x = ClampAABB(p.x);
    if (any(p.x!=before)){
        p.v *= (1.0 - _BoundaryDamp);
    }
    _Particles[i] = p;
}

// Recycle particles that fall below _RecycleY back into the emitter box
[numthreads(128,1,1)]
void RecycleBelow(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle p = _Particles[i];
    if (p.x.y < _RecycleY){
        uint seed = (uint)(i*73856093 + _Frame*19349663);
        float3 j = rand31(seed);
        float3 pos = _EmitterCenter + _EmitterSize * j;
        _OldPos[i] = pos - _EmitVel * max(_DeltaTime, 1e-4);
        p.x = pos;
        p.v = _EmitVel;
        p.rho = _RestDensity;
        p.lambda = 0;
        _Particles[i] = p;
    }
}

[numthreads(128,1,1)]
void UpdateVelocity(uint i:SV_DispatchThreadID){
    if (i>=_NumParticles) return;
    Particle p = _Particles[i];
    float3 oldx = _OldPos[i];
    p.v = (p.x - oldx) / max(_DeltaTime, 1e-6);
    _Particles[i] = p;
}
