// MC33IsoSurface.compute
#pragma kernel BuildGradients
#pragma kernel BuildIsoSurface
#pragma kernel InitIndirectArgs
#pragma kernel SetIndirectArgs

#include "CSDraw.hlsl"
#include "MC33LookUpTable.hlsl"

StructuredBuffer<float> _Volumes;                 // (Nx+1)*(Ny+1)*(Nz+1)
RWStructuredBuffer<float3> _Gradients;          // 同サイズ

cbuffer Params
{
    int3   _NumGrid;    // グリッド個数 (nx, ny, nz)
    float3 _Origin;     // メッシュ原点
    float3 _Step;       // グリッド間の距離
    float  _Iso;        // 境界面とする閾値
    
    uint _VerticesCapacity;
    uint _IndicesCapacity;
}

uint VolumeIndex(int x, int y, int z)
{
    uint nx1 = (uint)(_NumGrid.x + 1);
    uint ny1 = (uint)(_NumGrid.y + 1);
    return (uint)x + (uint)y * nx1 + (uint)z * nx1 * ny1;
}

float SampleVolume(int x, int y, int z)
{
    return _Volumes[VolumeIndex(x, y, z)];
}

float3 GradientFromCells(int x, int y, int z)
{
    float gx, gy, gz;

    if (x == 0) gx = SampleVolume(0, y, z) - SampleVolume(1, y, z);
    else if (x == _NumGrid.x) gx = SampleVolume(x - 1, y, z) - SampleVolume(x, y, z);
    else gx = 0.5 * (SampleVolume(x - 1, y, z) - SampleVolume(x + 1, y, z));

    if (y == 0) gy = SampleVolume(x, 0, z) - SampleVolume(x, 1, z);
    else if (y == _NumGrid.y) gy = SampleVolume(x, y - 1, z) - SampleVolume(x, y, z);
    else gy = 0.5 * (SampleVolume(x, y - 1, z) - SampleVolume(x, y + 1, z));

    if (z == 0) gz = SampleVolume(x, y, 0) - SampleVolume(x, y, 1);
    else if (z == _NumGrid.z) gz = SampleVolume(x, y, z - 1) - SampleVolume(x, y, z);
    else gz = 0.5 * (SampleVolume(x, y, z - 1) - SampleVolume(x, y, z + 1));

    return float3(gx, gy, gz);
}

float3 GetGridGradient(int x, int y, int z)
{
    return _Gradients[VolumeIndex(x, y, z)];
}

static const int3 s_cornerOffset[8] =
{
    int3(0,0,0), int3(0,1,0), int3(0,1,1), int3(0,0,1),
    int3(1,0,0), int3(1,1,0), int3(1,1,1), int3(1,0,1)
};

static const int2 s_edgeCorners[12] =
{
    int2(0,1), int2(1,2), int2(3,2), int2(0,3),
    int2(4,5), int2(5,6), int2(7,6), int2(4,7),
    int2(0,4), int2(1,5), int2(2,6), int2(3,7)
};

// ---- face/interior test（C#版相当）----
int FaceTests(inout int face[6], int ind, int sw, float v[8])
{
    if ((ind & 0x80) != 0)
    {
        face[0] = ((ind & 0xCC) == 0x84 ? (v[0] * v[5] < v[1] * v[4] ? -sw : sw) : 0);
        face[3] = ((ind & 0x99) == 0x81 ? (v[0] * v[7] < v[3] * v[4] ? -sw : sw) : 0);
        face[4] = ((ind & 0xF0) == 0xA0 ? (v[0] * v[2] < v[1] * v[3] ? -sw : sw) : 0);
    }
    else
    {
        face[0] = ((ind & 0xCC) == 0x48 ? (v[0] * v[5] < v[1] * v[4] ? sw : -sw) : 0);
        face[3] = ((ind & 0x99) == 0x18 ? (v[0] * v[7] < v[3] * v[4] ? sw : -sw) : 0);
        face[4] = ((ind & 0xF0) == 0x50 ? (v[0] * v[2] < v[1] * v[3] ? sw : -sw) : 0);
    }

    if ((ind & 0x02) != 0)
    {
        face[1] = ((ind & 0x66) == 0x42 ? (v[1] * v[6] < v[2] * v[5] ? -sw : sw) : 0);
        face[2] = ((ind & 0x33) == 0x12 ? (v[3] * v[6] < v[2] * v[7] ? -sw : sw) : 0);
        face[5] = ((ind & 0x0F) == 0x0A ? (v[4] * v[6] < v[5] * v[7] ? -sw : sw) : 0);
    }
    else
    {
        face[1] = ((ind & 0x66) == 0x24 ? (v[1] * v[6] < v[2] * v[5] ? sw : -sw) : 0);
        face[2] = ((ind & 0x33) == 0x21 ? (v[3] * v[6] < v[2] * v[7] ? sw : -sw) : 0);
        face[5] = ((ind & 0x0F) == 0x05 ? (v[4] * v[6] < v[5] * v[7] ? sw : -sw) : 0);
    }

    return face[0] + face[1] + face[2] + face[3] + face[4] + face[5];
}

int FaceTest1(int faceId, float v[8])
{
    switch (faceId)
    {
        case 0: return (v[0] * v[5] < v[1] * v[4] ? 0x48 : 0x84);
        case 1: return (v[1] * v[6] < v[2] * v[5] ? 0x24 : 0x42);
        case 2: return (v[3] * v[6] < v[2] * v[7] ? 0x21 : 0x12);
        case 3: return (v[0] * v[7] < v[3] * v[4] ? 0x18 : 0x81);
        case 4: return (v[0] * v[2] < v[1] * v[3] ? 0x50 : 0xA0);
        case 5: return (v[4] * v[6] < v[5] * v[7] ? 0x05 : 0x0A);
    }
    return 0;
}

int InteriorTest(int i, int flagtplane, float v[8])
{
    float At = v[4] - v[0];
    float Bt = v[5] - v[1];
    float Ct = v[6] - v[2];
    float Dt = v[7] - v[3];
    float t = At * Ct - Bt * Dt;

    if ((i & 0x01) != 0) { if (t <= 0.0) return 0; }
    else { if (t >= 0.0) return 0; }

    t = 0.5 * (v[3] * Bt + v[1] * Dt - v[2] * At - v[0] * Ct) / t;
    if (t <= 0.0 || t >= 1.0) return 0;

    At = v[0] + At * t;
    Bt = v[1] + Bt * t;
    Ct = v[2] + Ct * t;
    Dt = v[3] + Dt * t;

    float sBt = sign(Bt), sDt = sign(Dt), sAt = sign(At), sCt = sign(Ct), sVi = sign(v[i]);

    if ((i & 0x01) != 0)
    {
        if (At * Ct < Bt * Dt && sBt == sDt) return (sBt == sVi) ? 1 : 0 + flagtplane;
    }
    else
    {
        if (At * Ct > Bt * Dt && sAt == sCt) return (sAt == sVi) ? 1 : 0 + flagtplane;
    }
    return 0;
}

uint WriteGridVertex(int gx, int gy, int gz, float4 col, uint verticesCapacity)
{
    float3 p = float3(gx, gy, gz);
    float3 n = normalize(GetGridGradient(gx, gy, gz));
    return AppendVertex(p, n, col, verticesCapacity);
}

// エッジ頂点生成
bool WriteEdgeVertex(int cellX, int cellY, int cellZ, int edgeId, float v[8], float4 col, uint verticesCapacity)
{
    int2 cc = s_edgeCorners[edgeId];
    int ca = cc.x;
    int cb = cc.y;

    float va = v[ca];
    float vb = v[cb];

    int3 oa = s_cornerOffset[ca];
    int3 ob = s_cornerOffset[cb];

    int ax = cellX + oa.x;
    int ay = cellY + oa.y;
    int az = cellZ + oa.z;
    
    int bx = cellX + ob.x;
    int by = cellY + ob.y;
    int bz = cellZ + ob.z;

    // 浮動小数の "== 0" は危険なので epsilon に寄せる（CPU版よりGPU版で重要）
    const float epsZero = 1e-8;

    if (abs(va) < epsZero)
    {
        return WriteGridVertex(ax, ay, az, col, verticesCapacity);
    }
    if (abs(vb) < epsZero)
    {
        return WriteGridVertex(bx, by, bz, col, verticesCapacity);
    }

    // 線形補間 t
    float t = va / (va - vb);

    // 位置補間（グリッド空間）
    float3 pa = float3(ax, ay, az);
    float3 pb = float3(bx, by, bz);
    float3 p = lerp(pa, pb, t);

    // 法線（勾配）も線形補間
    float3 ga = GetGridGradient(ax, ay, az);
    float3 gb = GetGridGradient(bx, by, bz);
    float3 n = normalize(lerp(ga, gb, t));

    return AppendVertex(p, n, col, verticesCapacity);
}

// bool EnsureCenterVertex(int cellX, int cellY, int cellZ, inout bool has[13], inout float4 mcv[13])
// {
//     const int edgeId = 12;
//     if (has[edgeId]) return true;
//
//     float3 p = float3(cellX + 0.5, cellY + 0.5, cellZ + 0.5);
//     float3 n =
//         GetGridGradient(cellX,     cellY,     cellZ) +
//         GetGridGradient(cellX + 1, cellY,     cellZ) +
//         GetGridGradient(cellX,     cellY + 1, cellZ) +
//         GetGridGradient(cellX + 1, cellY + 1, cellZ) +
//         GetGridGradient(cellX,     cellY,     cellZ + 1) +
//         GetGridGradient(cellX + 1, cellY,     cellZ + 1) +
//         GetGridGradient(cellX,     cellY + 1, cellZ + 1) +
//         GetGridGradient(cellX + 1, cellY + 1, cellZ + 1);
//
//     n *= (1.0 / 8.0);
//
//     if (any(!isfinite(p)) || any(!isfinite(n)))
//         return false;
//
//     mcv[edgeId] = PackVertexNormal(p,n);
//     has[edgeId] = true;
//     return true;
// }

// Case判定＆出力（本体）
void FindCaseAndEmit(int x, int y, int z, int cubeIndex, float v[8])
{
    int pcase = Case_1_Top;
    int caseIndex = 0;

    int m = cubeIndex & 0x80;
    int c = Case_Index[(m != 0) ? (cubeIndex ^ 0xFF) : cubeIndex];

    int face[6] = {0,0,0,0,0,0};

    switch (c >> 8)
    {
        case 1: if ((c & 0x0080) != 0) m ^= 0x80; pcase = Case_1_Top; caseIndex = (c & 0x7F); break;
        case 2: if ((c & 0x0080) != 0) m ^= 0x80; pcase = Case_2_Top; caseIndex = (c & 0x7F); break;
        case 3:
            if ((c & 0x0080) != 0) m ^= 0x80;
            if (((m != 0 ? cubeIndex : (cubeIndex ^ 0xFF)) & FaceTest1((c & 0x7F) >> 1, v)) != 0)
            { pcase = Case_3_2_Top; caseIndex = 4 * (c & 0x7F); }
            else
            { pcase = Case_3_1_Top; caseIndex = 2 * (c & 0x7F); }
            break;
        case 4:
            if ((c & 0x0080) != 0) m ^= 0x80;
            if (InteriorTest((c & 0x7F), 0, v) != 0)
            { pcase = Case_4_2_Top; caseIndex = 6 * (c & 0x7F); }
            else
            { pcase = Case_4_1_Top; caseIndex = 2 * (c & 0x7F); }
            break;
        case 5: if ((c & 0x0080) != 0) m ^= 0x80; pcase = Case_5_Top; caseIndex = (c & 0x7F); break;
        case 6:
            if ((c & 0x0080) != 0) m ^= 0x80;
            if (((m != 0 ? cubeIndex : (cubeIndex ^ 0xFF)) & FaceTest1((c & 0x7F) % 6, v)) != 0)
            { pcase = Case_6_2_Top; caseIndex = 5 * (c & 0x7F); }
            else if (InteriorTest((c & 0x7F) / 6, 0, v) != 0)
            { pcase = Case_6_1_2_Top; caseIndex = 7 * (c & 0x7F); }
            else
            { pcase = Case_6_1_1_Top; caseIndex = 3 * (c & 0x7F); }
            break;
        case 7:
            if ((c & 0x0080) != 0) m ^= 0x80;
            switch (FaceTests(face, cubeIndex, (m != 0 ? 1 : -1), v))
            {
                case -3:
                    pcase = Case_7_1_Top;
                    caseIndex = 3 * (c & 0x7F);
                    break;

                case -1:
                    if (face[4] + face[5] == 1)
                    {
                        pcase = Case_7_2_1_Top;
                        caseIndex = 5 * (c & 0x7F);
                    }
                    else
                    {
                        int fi = (33825 >> ((c & 0x7F) << 1)) & 3;
                        pcase = (face[fi] == 1) ? Case_7_2_3_Top : Case_7_2_2_Top;
                        caseIndex = 5 * (c & 0x7F);
                    }
                    break;

                case 1:
                    if (face[4] + face[5] == -1)
                    {
                        pcase = Case_7_3_3_Top;
                        caseIndex = 9 * (c & 0x7F);
                    }
                    else
                    {
                        int fi = (33825 >> ((c & 0x7F) << 1)) & 3;
                        pcase = (face[fi] == 1) ? Case_7_3_2_Top : Case_7_3_1_Top;
                        caseIndex = 9 * (c & 0x7F);
                    }
                    break;

                case 3:
                    if (InteriorTest((c & 0x7F) >> 1, 0, v) != 0)
                    { pcase = Case_7_4_2_Top; caseIndex = 9 * (c & 0x7F); }
                    else
                    { pcase = Case_7_4_1_Top; caseIndex = 5 * (c & 0x7F); }
                    break;
            }
            break;

        case 8:
            pcase = Case_8_Top;
            caseIndex = (c & 0x7F);
            break;

        case 9:
            pcase = Case_9_Top;
            caseIndex = (c & 0x7F);
            break;

        case 10:
            switch (FaceTests(face, cubeIndex, (m != 0 ? 1 : -1), v))
            {
                case -2:
                {
                    bool a = (InteriorTest(0, 0, v) != 0);
                    bool b = (InteriorTest(((c & 0x01) != 0) ? 1 : 3, 0, v) != 0);

                    if (((c & 0x7F) != 0) ? (a || b) : (InteriorTest(0, 0, v) != 0))
                    { pcase = Case_10_1_2_1_Top; caseIndex = 8 * (c & 0x7F); }
                    else
                    { pcase = Case_10_1_1_1_Top; caseIndex = 4 * (c & 0x7F); }
                }
                    break;

                case 2:
                {
                    bool a = (InteriorTest(2, 0, v) != 0);
                    bool b = (InteriorTest(((c & 0x01) != 0) ? 3 : 1, 0, v) != 0);

                    if (((c & 0x7F) != 0) ? (a || b) : (InteriorTest(1, 0, v) != 0))
                    { pcase = Case_10_1_2_2_Top; caseIndex = 8 * (c & 0x7F); }
                    else
                    { pcase = Case_10_1_1_2_Top; caseIndex = 4 * (c & 0x7F); }
                }
                    break;

                case 0:
                {
                    // C#版と同様：face[0] or face[4] のどちらかを (c&0x7F) で選ぶ
                    int fi = 4 >> ((c & 0x7F) << 1);
                    pcase = (face[fi] == 1) ? Case_10_2_2_Top : Case_10_2_1_Top;
                    caseIndex = 8 * (c & 0x7F);
                }
                    break;
            }
            break;

        case 11:
            pcase = Case_11_Top;
            caseIndex = (c & 0x7F);
            break;

        case 12:
            switch (FaceTests(face, cubeIndex, (m != 0 ? 1 : -1), v))
            {
                case -2:
                    if (InteriorTest((int)LookUp_12_test_index(0, (int)(c & 0x7F)), 0, v) != 0)
                    { pcase = Case_12_1_2_1_Top; caseIndex = 8 * (c & 0x7F); }
                    else
                    { pcase = Case_12_1_1_1_Top; caseIndex = 4 * (c & 0x7F); }
                    break;

                case 2:
                    if (InteriorTest((int)LookUp_12_test_index(1, (int)(c & 0x7F)), 0, v) != 0)
                    { pcase = Case_12_1_2_2_Top; caseIndex = 8 * (c & 0x7F); }
                    else
                    { pcase = Case_12_1_1_2_Top; caseIndex = 4 * (c & 0x7F); }
                    break;

                case 0:
                    pcase = (face[(int)LookUp_12_test_index(2, (int)(c & 0x7F))] == 1) ? Case_12_2_2_Top : Case_12_2_1_Top;
                    caseIndex = 8 * (c & 0x7F);
                    break;
            }
            break;

        case 13:
        {
            int ct = FaceTests(face, cubeIndex, (m != 0 ? 1 : -1), v);

            switch (abs(ct))
            {
                case 6:
                    pcase = Case_13_1_Top;
                    caseIndex = 4 * ((ct > 0) ? 1 : 0);
                    break;

                case 4:
                {
                    int cc = (ct >> 2); // -1 or +1
                    int which = 0;
                    while (which < 6 && face[which] != -cc) ++which;

                    pcase = Case_13_2_Top;
                    caseIndex = 6 * (3 * cc + 3 + which);
                    break;
                }

                case 2:
                {
                    int bits =
                        (((((face[0] < 0) ? 1 : 0) << 1) | ((face[1] < 0) ? 1 : 0)) << 1 |
                         ((face[2] < 0) ? 1 : 0)) << 1 |
                        ((face[3] < 0) ? 1 : 0);

                    bits = (bits << 1) | ((face[4] < 0) ? 1 : 0);

                    pcase = Case_13_3_Top;
                    caseIndex = 10 * (25 - bits + ((((bits > 10) ? 1 : 0) + ((bits > 20) ? 1 : 0)) << 1));
                    break;
                }

                case 0:
                {
                    int cc = (((face[1] < 0) ? 1 : 0) << 1) | ((face[5] < 0) ? 1 : 0);

                    if (face[0] * face[1] * face[5] == 1)
                    {
                        pcase = Case_13_4_Top;
                        caseIndex = 12 * cc;
                    }
                    else
                    {
                        int it = InteriorTest(cc, 1, v);
                        if (it != 0)
                        {
                            pcase = Case_13_5_2_Top;
                            caseIndex = 10 * (cc | ((it & 1) << 2));
                        }
                        else
                        {
                            pcase = Case_13_5_1_Top;
                            caseIndex = 6 * cc;
                        }
                    }
                    break;
                }
            }
            break;
        }

        case 14:
            pcase = Case_14_Top;
            caseIndex = (c & 0x7F);
            break;
    }

    float4 col = float4(1.0f, 1.0f, 1.0f, 1.0f);
    
    int p[13];
    for (int pi = 0; pi < 13; pi++) p[pi] = -1;

    int code = cubeIndex;
    while (code != 0)
    {
        code = LookUp(pcase, caseIndex++);
        int f0 = 0, f1 = 0, f2 = 0;
        
        for (int k = 0; k < 3; k++)
        {
            int edgeId = code & 0x0F;

            if (p[edgeId] < 0)
            {
                if (edgeId == 12)
                {
                    // Interior center は元コード同等（勾配平均）
                    float3 center = float3(x + 0.5f, y + 0.5f, z + 0.5f);
                    float3 sumG =
                        GetGridGradient(x, y, z) + GetGridGradient(x + 1, y, z) +
                        GetGridGradient(x, y + 1, z) + GetGridGradient(x + 1, y + 1, z) +
                        GetGridGradient(x, y, z + 1) + GetGridGradient(x + 1, y, z + 1) +
                        GetGridGradient(x, y + 1, z + 1) + GetGridGradient(x + 1, y + 1, z + 1);

                    float3 n = normalize(sumG / 8.0f);
                    p[12] = AppendVertex(center, n, col, _VerticesCapacity);
                }
                else
                {
                    // 12本のエッジは共通関数で生成
                    p[edgeId] = WriteEdgeVertex(x, y, z, edgeId, v, col, _VerticesCapacity);
                }
            }
            
            if (k == 0) f0 = p[edgeId];
            else if (k == 1) f1 = p[edgeId];
            else f2 = p[edgeId];
            code >>= 4;
        }

// #if 1
        if (f0 != f1 && f0 != f2 && f1 != f2)
        {
#if defined(MC_Normal_neg)
            if (m != 0)
#else
            if (m == 0)
#endif
            {
                AppendTriangle(f2, f1, f0, _IndicesCapacity);
            }
            else
            {
                AppendTriangle(f0, f1, f2, _IndicesCapacity);
            }
        }
// #else        
        float3 p0 = float3(x, y, z);
        float3 p1 = float3(x + 1, y, z);
        float3 p2 = float3(x, y + 1, z);
        uint i0 = AppendVertex(p0, GetGridGradient(x, y, z), float4(1,1,1,1), _VerticesCapacity);
        uint i1 = AppendVertex(p1, GetGridGradient(x + 1, y, z), float4(1,1,1,1), _VerticesCapacity);
        uint i2 = AppendVertex(p2, GetGridGradient(x, y + 1, z), float4(1,1,1,1), _VerticesCapacity);
        AppendTriangle(i0, i1, i2, _IndicesCapacity);
// #endif
    }
}

// ===== Kernels =====

[numthreads(8,8,8)]
void BuildGradients(uint3 id : SV_DispatchThreadID)
{
    int nx1 = _NumGrid.x + 1;
    int ny1 = _NumGrid.y + 1;
    int nz1 = _NumGrid.z + 1;

    int x = (int)id.x;
    int y = (int)id.y;
    int z = (int)id.z;

    if (x >= nx1 || y >= ny1 || z >= nz1) return;

    _Gradients[VolumeIndex(x,y,z)] = GradientFromCells(x,y,z);
}

[numthreads(8,8,8)]
void BuildIsoSurface(uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x, y = (int)id.y, z = (int)id.z;
    if (x >= _NumGrid.x || y >= _NumGrid.y || z >= _NumGrid.z) return;

    float v[8];

    float V00 = SampleVolume(x, y, z);
    float V01 = SampleVolume(x, y + 1, z);
    float V11 = SampleVolume(x, y + 1, z + 1);
    float V10 = SampleVolume(x, y, z + 1);
    v[0] = _Iso - V00;
    v[1] = _Iso - V01;
    v[2] = _Iso - V11;
    v[3] = _Iso - V10;

    V00 = SampleVolume(x + 1, y, z);
    V01 = SampleVolume(x + 1, y + 1, z);
    V11 = SampleVolume(x + 1, y + 1, z + 1);
    V10 = SampleVolume(x + 1, y, z + 1);
    v[4] = _Iso - V00;
    v[5] = _Iso - V01;
    v[6] = _Iso - V11;
    v[7] = _Iso - V10;

    uint idx =
        ((v[0] >= 0.0 ? 1 : 0) << 7) |
        ((v[1] >= 0.0 ? 1 : 0) << 6) |
        ((v[2] >= 0.0 ? 1 : 0) << 5) |
        ((v[3] >= 0.0 ? 1 : 0) << 4) |
        ((v[4] >= 0.0 ? 1 : 0) << 3) |
        ((v[5] >= 0.0 ? 1 : 0) << 2) |
        ((v[6] >= 0.0 ? 1 : 0) << 1) |
        ((v[7] >= 0.0 ? 1 : 0) << 0);

    if (idx == 0 || idx == 0xFF) return;

    FindCaseAndEmit(x, y, z, idx, v);
}
