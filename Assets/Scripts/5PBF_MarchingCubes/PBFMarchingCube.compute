#pragma kernel InitPoolList
#pragma kernel InitParticles
#pragma kernel SpawnParticles
#pragma kernel UpdateParticles
#pragma kernel ClearVolumes
#pragma kernel BuildVolumes

#include "Particle.hlsl"

RWStructuredBuffer<Particle> Particles;
AppendStructuredBuffer<uint> AliveList;

AppendStructuredBuffer<uint> PoolAppend;
ConsumeStructuredBuffer<uint> PoolConsume;

RWStructuredBuffer<uint> _DispatchArgs;   //[0] numActiveParticle
StructuredBuffer<uint> _ActiveList;
RWStructuredBuffer<int> _Volumes;

cbuffer Params
{
    uint _Capacity;
    uint _FrameCount;
    uint _SpawnCount;
    float _DeltaTime;
    float _Gravity;
    float3 _BoundsCenter;
    float3 _BoundsSize;
    // 斥力が発生する半径
    float _RepulsionRadius;
    float _RepulsionStrength;
    
    int3 _NumGrid;
    // 実体の半径
    float _ParticleRadius;
    // パーティクルの質量
    float _ParticleMass;
};

uint GetSeed(uint3 dispatchThreadID, uint _FrameCount)
{
    return (dispatchThreadID.x * 73856093u) ^ (dispatchThreadID.y * 19349663u) ^ (dispatchThreadID.z * 83492791u) ^ _FrameCount;
}

uint Hash(uint x)
{
    x ^= x >> 17;
    x *= 0xED5AD4BBu;
    x ^= x >> 11;
    x *= 0xAC4C1B51u;
    x ^= x >> 15;
    x *= 0x31848BABu;
    x ^= x >> 14;
    return x;
}

// [0.0, 1.0)の範囲でランダムなfloat3を生成
float3 RandomFloat3(uint seed)
{
    uint h1 = Hash(seed);
    uint h2 = Hash(seed * 1664525u + 1013904223u);
    uint h3 = Hash(seed * 22695477u + 1u);

    return float3(
        h1 / 4294967296.0,
        h2 / 4294967296.0,
        h3 / 4294967296.0
    );
}

[numthreads(128,1,1)]
void InitPoolList (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _Capacity) return;

    PoolAppend.Append(i);
}

[numthreads(128,1,1)]
void InitParticles(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _Capacity) return;
    Particle p;
    p.position = float3(0,0,0);
    p.radiusScale = 1.0 + (float)i / (_Capacity * 10.0);    // ID順に[1.0, 1.1)の範囲でサイズを微妙に変える
    p.velocity = float3(0,0,0);
    p.life = 0.0;
    // p.color = half4(1,1,1,1);
    p.color = (float)i / (float)_Capacity; 
    Particles[i] = p;
}

[numthreads(128,1,1)]
void SpawnParticles (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _SpawnCount) return;

    uint newIndex = PoolConsume.Consume();
 
    Particle p = Particles[newIndex];
    float3 pos = RandomFloat3(GetSeed(id, _FrameCount)) * 2.0f - 1.0f;
    p.position = float3(pos.x, 9.0f, pos.z);
    p.velocity = float3(0.0f, 0.0f, 0.0f);
    // p.color = half4(1.0, 1.0, 1.0, 1.0);
    p.life = 1.0f;
    Particles[newIndex] = p;
}

[numthreads(128,1,1)]
void UpdateParticles (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _Capacity) return;

    Particle p = Particles[i];
    if (p.life <= 0.0f)
    {
        return;
    }
    
    // p.color = 0;
    
    float3 boundsMin = _BoundsCenter - _BoundsSize * 0.5f + p.radiusScale * _RepulsionRadius;
    float3 boundsMax = _BoundsCenter + _BoundsSize * 0.5f - p.radiusScale * _RepulsionRadius;
    
    float3 oldPos = p.position;
    
    p.velocity -= float3(0.0f, _Gravity * _DeltaTime, 0.0f);
    p.position += p.velocity * _DeltaTime;
    
    // p.color.g = 0.0f;
    // 斥力半径内のパーティクルから弾かれる
    for (uint j = 0; j < _Capacity; j++)
    {
        if (i == j) continue;
        Particle other = Particles[j];
        if (other.life <= 0.0f) continue;
        
        float3 toOther = other.position - p.position;
        float dist = length(toOther);
        
        // velocityではなくpositionに直接影響を与える
        if (dist < _RepulsionRadius && dist > 0.0f)
        {
            float3 repulsionDir = normalize(toOther);
            float repulsionStrength = (_RepulsionRadius - dist) / _RepulsionRadius;
            p.position -= repulsionDir * repulsionStrength * _RepulsionStrength * _DeltaTime;
            // p.color.g = 1.0f;
        }
    }

    // 壁に衝突したら反射
    float3 hitMin = step(p.position, boundsMin);
    float3 hitMax = step(boundsMax, p.position);
    float3 hit = saturate(hitMax + hitMin);
    // p.color.r = saturate(hit.x + hit.y + hit.z);
    
    p.position = clamp(p.position, boundsMin, boundsMax);
    float bounce = 0.2;
    float3 signFlip = 1.0 + hit * (-bounce - 1.0);
    p.velocity *= signFlip;
    
    // if (p.position.y < 0.0f)
    // {
    //     p.life = 0.0f;
    //     Particles[i] = p;
    //     PoolAppend.Append(i);
    //     return;
    // }
    
    Particles[i] = p;
    AliveList.Append(i);
}

uint VolumeIndex(int x, int y, int z)
{
    uint nx1 = (uint)(_NumGrid.x + 1);
    uint ny1 = (uint)(_NumGrid.y + 1);
    return (uint)x + (uint)y * nx1 + (uint)z * nx1 * ny1;
}

[numthreads(8,8,8)]
void ClearVolumes(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;
    uint z = id.z;

    if (x >= _NumGrid.x + 1 || y >= _NumGrid.y + 1 || z >= _NumGrid.z + 1) return;

    uint index = VolumeIndex(x, y, z);
    _Volumes[index] = 0;
}

[numthreads(128,1,1)]
void BuildVolumes(uint3 id : SV_DispatchThreadID)
{
    //    _DispatchArgs[0]がアクティブなパーティクル数
    uint numActive = _DispatchArgs[0];
    uint i = id.x;
    if (i >= numActive) return;
    
#if 0    
    // パーティクルのグリッド位置を計算して_Volumesにインクリメントする
    uint particleIndex = _ActiveList[i];
    Particle p = Particles[particleIndex];
    float3 localPos = p.position - (_BoundsCenter - _BoundsSize * 0.5f);
    int3 gridPos = int3(floor(localPos / _BoundsSize * float3(_NumGrid)));
    gridPos = clamp(gridPos, int3(0,0,0), _NumGrid - int3(1,1,1));
    uint volIndex = VolumeIndex(gridPos.x, gridPos.y, gridPos.z);
    InterlockedAdd(_Volumes[volIndex], 1);
#else
    // _ParticleRadiusを考慮してパーティクルが影響を与えるボリュームを計算し、_Volumesにインクリメントする
    // 増やす値は_ParticleMassがそのボリューム内に存在する質量として扱う
    uint particleIndex = _ActiveList[i];
    Particle p = Particles[particleIndex];

    float3 boundsMin = _BoundsCenter - _BoundsSize * 0.5f;
    float3 cellSize = _BoundsSize / float3(_NumGrid);
    float cellVolume = cellSize.x * cellSize.y * cellSize.z;

    float radius = _ParticleRadius;
    float sphereVolume = (4.0f / 3.0f) * 3.14159265f * radius * radius * radius;
    if (sphereVolume <= 0.0f)
    {
        return;
    }

    float3 localPos = p.position - boundsMin;
    int3 gridPos = int3(floor(localPos / cellSize));
    gridPos = clamp(gridPos, int3(0, 0, 0), _NumGrid - int3(1, 1, 1));

    const int SAMPLE = 2;
    const float SCALE = 65536.0f;

    // パーティクルが影響を与える最大27セル（中心と周囲1セルの3×3×3）
    for (int dz = -1; dz <= 1; dz++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            for (int dx = -1; dx <= 1; dx++)
            {
                int3 cell = gridPos + int3(dx, dy, dz);
                if (cell.x < 0 || cell.y < 0 || cell.z < 0 ||
                    cell.x >= _NumGrid.x || cell.y >= _NumGrid.y || cell.z >= _NumGrid.z)
                {
                    continue;
                }

                float3 cellMin = boundsMin + float3(cell) * cellSize;
                float3 sampleStep = cellSize / (float)SAMPLE;

                int insideCount = 0;
                for (int sz = 0; sz < SAMPLE; sz++)
                {
                    for (int sy = 0; sy < SAMPLE; sy++)
                    {
                        for (int sx = 0; sx < SAMPLE; sx++)
                        {
                            float3 samplePos = cellMin + (float3(sx + 0.5f, sy + 0.5f, sz + 0.5f) * sampleStep);
                            float distSq = dot(samplePos - p.position, samplePos - p.position);
                            if (distSq <= radius * radius)
                            {
                                insideCount++;
                            }
                        }
                    }
                }

                float fraction = (float)insideCount / (float)(SAMPLE * SAMPLE * SAMPLE);
                float overlapVolume = fraction * cellVolume;
                float contributionMass = overlapVolume / sphereVolume * _ParticleMass;

                int delta = (int)round(contributionMass * SCALE);
                if (delta != 0)
                {
                    uint volIndex = VolumeIndex(cell.x, cell.y, cell.z);
                    InterlockedAdd(_Volumes[volIndex], delta);
                }
            }
        }
    }
#endif
}

